{
  "folders": [
    {
      "path": ".."
    }
  ],
  "settings": {
    "regexrobin.rules": [
      // Jira links, like "ISSUE-123"
      {
        "regex": "ISSUE-\\d+",
        "tree": { "group": "Jira links" },
        "editor": [
          {
            "link": "https://myorg.atlassian.net/browse/$0",
            "color": "#66D9EF",
            "hoverMessage": "Jira ticket **$0**"
          }
        ]
      },
      // Turns a pasted github pull request URL into something more readable,
      // like https://github.com/dlevs/duration-fns/pull/20.
      {
        "regex": "(https://github.com/.+?/)(.*?)(/pull/)(\\d+)",
        "editor": [
          { "color": "#66D9EF" },
          // Rather than replace the entire match, just replace parts of it, so the
          // majority of what is shown _is_ the original string, so cursor position
          // is predictable when it expands upon click.
          { "group": 1, "inlineReplacement": "" },
          { "group": 3, "inlineReplacement": "#" }
        ]
      },
      // Accentuate all occurrences of "NOTE:"
      {
        "regex": "(NOTE):",
        "editor": [
          { "color": "#AE81FF" },
          {
            "group": 1,
            "fontWeight": "bold",
            "textDecoration": "underline"
          }
        ]
      },
      // Color all text after the word "NOTE:", and populate the tree view with
      // the text. This uses a regex template for reusability.
      {
        "regex": {
          "template": "multi-line-match",
          "replace": { "TEXT": "NOTE" }
        },
        "tree": { "group": "Notes", "label": "$1" },
        "editor": [{ "group": 1, "color": "#AE81FF" }]
      },
      // Accentuate all occurrences of "TODO:"
      {
        "regex": "(TODO):",
        "editor": [
          { "color": "#F92672" },
          {
            "group": 1,
            "fontWeight": "bold",
            "textDecoration": "underline"
          }
        ]
      },
      // Color all text after the word "TODO:", and populate the tree view with
      // the text. This uses a regex template for reusability.
      {
        "regex": {
          "template": "multi-line-match",
          "replace": { "TEXT": "TODO" }
        },
        "tree": { "group": "TODOs", "label": "$1" },
        "editor": [{ "group": 1, "color": "#F92672" }]
      },
      // A bit of a hack to make the "*" and "//" comment characters gray again,
      // since the NOTE and TODO rules above overrode them.
      {
        "regex": "^ *(//|\\*/|\\*|#|-|\\d+\\.)[^#] *",
        "regexFlags": { "multiline": true },
        "editor": [{ "color": "gray" }]
      },
      // An example of shortening text, like TIP: This is long text but will be shortened.
      {
        "regex": "TIP: .{1,14}(.+)?",
        "editor": [
          { "color": "#E6DB74", "hoverMessage": "$0" },
          {
            "group": 1,
            "inlineReplacement": "..."
          }
        ]
      },
      // An example of shortening text in such a way that leads to worse UX when
      // clicking on the replacement, like ((Short text ahoy!))
      {
        "regex": "\\(\\((.{0,7}).*?\\)\\)",
        "editor": [
          {
            "color": "#AE81FF",
            "borderRadius": "3px",
            "gutterIconPath": "/Users/daniellevett/Projects/vscode-regex-robin/assets/icon.png",
            "gutterIconSize": "contain",
            "inlineReplacement": {
              "contentText": "ðŸ‘€ $1",
              "color": "#FD971F"
            },
            "hoverMessage": "This style of shortening is not recommended because it replaces the entirety of the text, so when you click on it, the cursor always jumps to the start or end of the line.\n\nIt's better to use `inlineReplacement` for the specific capture groups you want to hide."
          }
        ]
      },
      // Highlighting of handlebars-style variables, like "{{foo}}"
      {
        "regex": "{{(\\w*?)}}",
        "regexFlags": { "ignoreCase": true },
        "editor": [
          { "color": "#E6DB74" },
          { "group": 1, "color": "#66D9EF", "textDecoration": "underline" }
        ]
      },
      // Markdown link, like [Google](https://google.com)
      {
        "regex": "(\\[.+?\\])(\\((.+?)\\))",
        "editor": [
          { "hoverMessage": "Link to $3", "color": "#66D9EF" },
          // A limitation here is that the link must be applied only to the first group,
          // since group 2 will already have a link provided, and they can't be nested -
          // the outer link will just not work.
          { "group": 1, "link": "$3" },
          { "group": 2, "inlineReplacement": "" }
        ]
      },
      // HTML class attributes, like "class="foo bar""
      {
        "regex": "class=\"(.*?)\"",
        "editor": [
          {
            "group": 1,
            "inlineReplacement": { "contentText": "â€¢â€¢â€¢", "color": "#666" }
          }
        ]
      }
    ],
    "regexrobin.templates": {
      // A regex that matches all text after a given word, wrapping onto the next line
      // (but not 2 consecutive lines), as long as the next line is the same as the
      // matched line in terms of comment style.
      "multi-line-match": {
        "regex": [
          // Opening comment (first 3) / bullet point / start of line
          ["//.*?", "\\*.*?", "#.*?", "-.*?", "^ *?"],

          "TEXT:(",

          /*  */ // Anything between comment and end of line
          /*  */ ".*",

          /*  */ // Try to extend the match to the next line if possible
          /*  */ "(?:",
          /*      */ // New line
          /*      */ "\n *",
          /*      */ //  New line comment
          /*      */ ["// +?", "\\* +?", "# +?", "[^-] +?", "^ *?"],
          /*      */ // Content on the new line up until the next "TEXT".
          /*      */ // There _must_ be content, otherwise the match is over.
          /*      */ "(?:(?!TEXT).)+$",
          /*  */ ")*",

          ")"
        ],
        "regexFlags": { "multiline": true }
      }
    }
  }
}
